<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.1">
    <title>What's New In Schematron 4</title><!-- TODO: SVRL equivalents? -->
    <part>
        <title>New attributes</title>
        <chapter>
            <title><tag class="attribute">as</tag></title>
            <itemizedlist>
                <title>Element context(s)</title>
                <listitem>
                    <para><tag class="element">let</tag></para>
                </listitem>
            </itemizedlist>
            <para>This attribute is <emphasis role="bold">optional</emphasis> and expresses the datatype of a variable declared by element <tag class="element">let</tag>.</para>
            <blockquote role='iso'>
                <title>Clause 5.4.7 (<literal>let</literal> element)</title>
                <para>The optional <literal>as</literal> attribute is the datatype of the variable. The query language binding shall determine whether the <literal>as</literal> attribute is supported and how it is processed.</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting>let =
    element let {
        attribute name { nameValue },
        <phrase role="highlight">attribute as { text }?</phrase>,
        (attribute value { string }
         | foreign-element+)
    }</programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/1">Typed variables</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example>
                    <title><tag class="attribute">as</tag> attribute: <tag class="attribute">value</tag> attribute of <tag class="element">sch:let</tag></title>
                    <programlisting language="xml"><![CDATA[<sch:let name='foo' as='xs:integer' value='12'/>]]></programlisting>
                </example>
                <example>
                    <title><tag class="attribute">as</tag> attribute: element content of <tag class="element">sch:let</tag></title>
                    <programlisting language="xml"><![CDATA[<sch:let name='foo' as='element(foo)'><foo/></sch:let>]]></programlisting>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>The introduction of this attribute removes the need for implementations to provide custom workarounds, for example the use of <literal>xsl:variable</literal> in XSLT.</para>
            </section>
        </chapter>
        <chapter>
            <title><tag class="attribute">from</tag></title>
            <itemizedlist>
                <title>Element context(s)</title>
                <listitem>
                    <para><tag class="element">phase</tag></para>
                </listitem>
            </itemizedlist>
            <para>This attribute is <emphasis role="bold">optional</emphasis> and restricts evaluation of the patterns the phase contains to the subset of the document its expression matches.</para>
            <blockquote role='iso'>
                <title>Clause 5.4.13 (<literal>phase</literal> element)</title>
                <para>The optional <literal>from</literal> attribute [...] can be used to restrict validation to a subset of a document.</para>
            </blockquote>            
            <blockquote role='iso'>
                <title>Clause 5.5.7 (<literal>from</literal> attribute)</title>
                <para>The <literal>from</literal> attribute contains an expression which restricts the evaluation of patterns in a phase to the subset of the document it selects.</para>
                <para xml:id="iso-from-attr">The expression shall be evaluated in the context of the instance document root. The results become the context against which rule <literal>context</literal> expressions are evaluated. Variables evaluated in the context of the instance document root are not influenced by the presence of <literal>from</literal> and so are evaluated and scoped as usual.</para>
                <para>This behaviour shall not apply to subordinate documents, that is those selected by the <literal>documents</literal> attribute [...].</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting>phase =
     element phase {
         attribute id { xsd:ID },
         <phrase role="highlight">attribute from { text }?</phrase>,
         attribute when { pathValue }?,
         rich,
         (foreign &amp; inclusion* &amp; (p*, let*, active*))
     }</programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/72">Enhancement for sch:phase - @start-at</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example xml:id="from-att">
                    <title><literal>from</literal> attribute</title>
                    <para>Given this instance document:</para>
                    <programlisting language="xml"><![CDATA[<foo>
    <blort wibble='1'/>
    <bar>]]><phrase role='highlight'><![CDATA[<blort wibble='2'/><blort wibble='3'/>]]></phrase><![CDATA[</bar>
</foo>]]></programlisting>
                    <para>and this schema:</para>
                    <programlisting language="xml"><![CDATA[<sch:schema schematronEdition='2025' defaultPhase='wibble'>
  <sch:phase id='wibble' ]]><phrase role="highlight">from='/foo/bar'</phrase><![CDATA[>
    <sch:active pattern='wibble'/>
  </sch:phase>
  <sch:pattern id='wibble'>
    <sch:rule context='.//blort[@wibble]'>
      <sch:report test='@wibble'><sch:value-of select='@wibble'/></sch:report>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>
                    <para>only the two instances of <tag class="element">wibble</tag> (highlighted, at XPath <literal>/foo/bar/blort</literal>) will be reported, because the <tag class="attribute">from</tag> attribute constrains the evaluation context to the XPath given (<literal>/foo/bar</literal>).</para>
                </example>
                <example xml:id="from-att-empty-sequence">
                    <title><literal>from</literal> attribute: evaluation returns the empty sequence</title>
                    <para>Given the same instance document as <link linkend="from-att">above</link> and this schema:</para>
                    <programlisting language="xml"><![CDATA[<sch:schema schematronEdition='2025' defaultPhase='wibble'>
  <sch:phase id='wibble' ]]><phrase role="highlight">from='/no/such/path'</phrase><![CDATA[>
    <sch:active pattern='wibble'/>
  </sch:phase>
  <sch:pattern id='wibble'>
    <sch:rule context='.//blort[@wibble]'>
      <sch:report test='@wibble'><sch:value-of select='@wibble'/></sch:report>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>
                    <para>nothing is returned because evaluating <tag class="attribute">from</tag> (highlighted) returns the empty sequence. The rule will consequently not fire and none of its assertions will be evaluated.</para>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>The implication of the phrase "<link linkend="iso-from-attr">The results become the context against which rule <literal>context</literal> expressions are evaluated</link>" is that if the results are the empty sequence, there is nothing to validate and so the active patterns belonging to the phase are not evaluated (see <xref linkend="from-att-empty-sequence"/>).</para>
            </section>
        </chapter>
        <chapter>
            <title><tag class="attribute">schematronEdition</tag></title>
            <itemizedlist>
                <title>Element context(s)</title>
                <listitem>
                    <para><tag class="element">schema</tag></para>
                </listitem>
            </itemizedlist>
            <para>This attribute is <emphasis role="bold">optional</emphasis> and states the version of Schematron (i.e. which edition of the standard) the schema conforms to. The attribute is shown in all schema examples given in this guide, for clarity.</para>
            <blockquote role='iso'>
                <title>Clause 5.5.15 (<literal>schematronEdition</literal> attribute)</title>
                <para>The value of this attribute where specified shall be <literal>2025</literal>.</para>
                <para>Schemas should specify this attribute.</para>
                <para>Implementations shall report the value or the absence of this attribute at user option.</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting>element schema {
        attribute id { xsd:ID }?,
        rich,
        attribute schemaVersion { non-empty-string }?,
        <phrase role="highlight">attribute schematronEdition { non-empty-string }?</phrase>,
        attribute defaultPhase { xsd:IDREF }?,
        attribute queryBinding { non-empty-string }?,
        (foreign
         &amp; (inclusion | extends)*
         &amp; (title?, ns*, p*, param*, let*, phase*, abstract-rules*, (rule-set|pattern)+, p*, diagnostics?, properties?))
    }</programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/42">Proposal for proper language versioning system</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example>
                    <title><literal>schematronEdition</literal> attribute</title>
                    <programlisting language="xml"><![CDATA[<sch:schema ]]><phrase role="highlight">schematronEdition='2025'</phrase><![CDATA[>
  <sch:pattern>
    <sch:rule context='*'>
      <sch:report test='true()'><sch:name/></sch:report>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>
                    <para>The implementation <link xlink:href="https://github.com/AndrewSales/XQS">XQS</link> for example implements this feature using a command-line (and API) option, <literal>report-edition</literal>. If this is switched on, the application reports an empty <tag class="element">schema</tag> element, including any <tag class="attribute">schematronEdition</tag> attribute, as the first item returned, e.g.</para>
                    <programlisting language="xml"><![CDATA[<schema xmlns='http://purl.oclc.org/dsdl/schematron' ]]><phrase role="highlight">schematronEdition='2025'</phrase><![CDATA[/>]]></programlisting>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>This attribute provides a mechanism to differentiate the version of schema markup used without changing the namespace for schemas generally, in the interests of backward compatibility.</para>
            </section>
        </chapter>        
        <chapter>
            <title><tag class="attribute">severity</tag></title>
            <itemizedlist>
                <title>Element context(s)</title>
                <listitem>
                    <para><tag class="element">assert</tag></para>
                </listitem>
                <listitem>
                    <para><tag class="element">report</tag></para>
                </listitem>
            </itemizedlist>
            <para>This attribute is <emphasis role="bold">optional</emphasis> and expresses the relative importance of an assertion.</para>
            <blockquote role='iso'>
                <title>Clause 5.5.16 (<literal>severity</literal> attribute)</title>
                <para>The following values are reserved for use and without further definition: <literal>fatal</literal>, <literal>error</literal>, <literal>warning</literal>, <literal>info</literal>.</para>
                <para>If the value of a <literal>severity</literal> attribute given in a schema is a variable reference, its value shall be dynamically evaluated. This mechanism is provided to enable the severity value to vary, for example according to the selected phase and its in-scope variables.</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting><phrase role="highlight">severity = attribute severity{ text }?</phrase></programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/58">Add attribute named e.g. 'severity' to schematron with well defined semantics for reporting severity levels</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example>
                    <title><literal>severity</literal> attribute: element <tag class="element">report</tag></title>
                    <para>Assertion:</para>
                    <programlisting><![CDATA[<sch:report test='true()' ]]><phrase role="highlight">severity='warning'</phrase><![CDATA[>...</sch:report>]]></programlisting>
                    <para>SVRL output:</para>
                    <programlisting><![CDATA[<svrl:successful-report test='true()' ]]><phrase role="highlight">severity='warning'</phrase><![CDATA[>...</svrl:successful-report>]]></programlisting>                    
                </example>
                <example>
                    <title><literal>severity</literal> attribute: element <tag class="element">assert</tag></title>
                    <para>Assertion:</para>
                    <programlisting><![CDATA[<sch:assert test='false()' ]]><phrase role="highlight">severity='error'</phrase><![CDATA[>...</sch:assert>]]></programlisting>
                    <para>SVRL output:</para>
                    <programlisting><![CDATA[<svrl:failed-assert test='false()' ]]><phrase role="highlight">severity='error'</phrase><![CDATA[>...</svrl:failed-assert>]]></programlisting>
                </example>
                <example>
                    <title><literal>severity</literal> attribute: user-defined value</title>
                    <para>Assertion:</para>
                    <programlisting><![CDATA[<sch:assert test='false()' ]]><phrase role="highlight">severity='M-5093-K4'</phrase><![CDATA[>...</sch:assert>]]></programlisting>
                    <para>SVRL output:</para>
                    <programlisting><![CDATA[<svrl:failed-assert test='false()' ]]><phrase role="highlight">severity='M-5093-K4'</phrase><![CDATA[>...</svrl:failed-assert>]]></programlisting>
                </example>
                    <example>
                        <title><literal>severity</literal> attribute: dynamic evaluation</title>
                        <para>Schema:</para>
                    <programlisting><![CDATA[<sch:schema schematronEdition='2025']]><phrase role="highlight">defaultPhase='phase'</phrase><![CDATA[>
  <sch:ns prefix='a' uri='b'/>
  <sch:let name='c' value='d'/>
  <sch:phase id=']]><phrase role="highlight">phase</phrase><![CDATA['>
    <sch:let name=']]><phrase role="highlight">dynamic-severity</phrase><![CDATA[' value=']]><phrase role="highlight">"bar"</phrase><![CDATA['/>
    <sch:active pattern='foo'/>
  </sch:phase>
  <sch:pattern id='foo'>
    <sch:rule context='*'>
      <sch:assert test='false()' severity=']]><phrase role="highlight">$dynamic-severity</phrase><![CDATA['>...</sch:assert>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>    
                    <para>SVRL output for failed assertion:</para>
                    <programlisting><![CDATA[<svrl:failed-assert test='false()' ]]><phrase role="highlight">severity='bar'</phrase><![CDATA[>...</svrl:failed-assert>]]></programlisting>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>This value of this attribute (along with <tag class="attribute">flag</tag> and <tag class="attribute">role</tag>) can now be dynamically evaluated on output to SVRL.</para>
                <para>For details, see <xref linkend="dynamic-atts"/>.</para>
            </section>
        </chapter>
        <chapter>
            <title><tag class="attribute">visit-each</tag></title>
            <itemizedlist>
                <title>Element context(s)</title>
                <listitem>
                    <para><tag class="element">rule</tag></para>
                </listitem>
            </itemizedlist>
            <para>This attribute is <emphasis role="bold">optional</emphasis> and selects items matched by a <literal>rule</literal> context for further evaluation.</para>
            <blockquote role='iso'>
                  <title>Clause 5.5.21 (<literal>visit-each</literal> attribute)</title>
                <para>The <literal>visit-each</literal> attribute contains an expression which selects a sequence of items for further evaluation.</para>
                <para>The expression is evaluated against each item resulting from evaluation of the rule's context expression. If this sequence is non-empty, it becomes the context against which assertions are evaluated, in place of the rule's context. If it is empty, the rule is still considered to have fired.</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting>element rule {
        attribute flag { flagValue }?,
        rich,
        linkable,
        (foreign
         &amp; inclusion*
         &amp; ((attribute context { pathValue },
               <phrase role="highlight">attribute visit-each { pathValue }?</phrase>,
               attribute id { xsd:ID }?,
               attribute abstract { "false" }?,
               title?,
               let*,
               (assert | report | extends | p)+)))
    }</programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/75">Checking for substrings of the node values</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example>
                    <title><literal>visit-each</literal> attribute</title>
                    <para>Validating this document:</para>
                    <programlisting language="xml"><![CDATA[<foo>foo bar blort foo bar</foo>]]></programlisting>
                    <para>against a schema containing this rule:</para>
                    <programlisting language="xml"><![CDATA[<sch:rule context='foo' visit-each='fn:analyze-string(., "foo")/fn:match'>
  <sch:report test='.'><sch:name/> at index <sch:value-of select='string-length(string-join(preceding-sibling::fn:*))+1'/></sch:report>
</sch:rule>]]></programlisting>
                    <para>produces SVRL output containing:</para>
                    <programlisting language="xml"><![CDATA[<svrl:fired-rule context="/foo" ]]><phrase role='highlight'>visit-each="analyze-string(., &quot;foo&quot;)/fn:match"</phrase><![CDATA[/>
<successful-report xmlns="http://purl.oclc.org/dsdl/svrl" location="Q{http://www.w3.org/2005/xpath-functions}root()/Q{http://www.w3.org/2005/xpath-functions}match[1]" test=".">
  <svrl:text>foo at index 1</svrl:text>
</successful-report>
<successful-report xmlns="http://purl.oclc.org/dsdl/svrl" location="Q{http://www.w3.org/2005/xpath-functions}root()/Q{http://www.w3.org/2005/xpath-functions}match[2]" test=".">
  <svrl:text>foo at index 15</svrl:text>
</successful-report>]]></programlisting>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>This attribute effectively allows the schema author to iterate over the sequence of items returned. While the rule context expression in the example above can (depending on the query language binding) be re-written as</para>
                <programlisting language="xml">/foo/analyze-string(., "foo")/fn:match</programlisting>                <para>and produce the same result, <tag class="attribute">visit-each</tag> enables the expression to be decomposed for clarity.</para>
            </section>
        </chapter>
        <chapter>
            <title><tag class="attribute">when</tag></title>
            <itemizedlist>
                <title>Element context(s)</title>
                <listitem>
                    <para><tag class="element">phase</tag></para>
                </listitem>
            </itemizedlist>
            <para>This attribute is <emphasis role="bold">optional</emphasis> and activates the phase when its expression matches.</para>
            <blockquote role='iso'>
                <title>Clause 5.4.13 (<literal>phase</literal> element)</title>
                <para>The string <literal>#ANY</literal> denotes that the active phase is selected using the method given in [<link xlink:href="#when-attr">Clause 5.5.22</link>] and if no active phase is selected, then all patterns are active.</para>
            </blockquote>
            <blockquote role='iso' xml:id="when-attr">
                <title>Clause 5.5.22 (<literal>when</literal> attribute)</title>
                <para>The <literal>when</literal> attribute is an expression evaluated to a Boolean in the context of the instance document root. If the expression evaluates to <literal>true()</literal>, then its parent phase becomes active. The first such phase declared in schema document order shall be the active phase.</para>
                <para>This behaviour shall not apply to subordinate documents, that is those selected by the <literal>documents</literal> attribute [...].</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting>phase =
     element phase {
         attribute id { xsd:ID },
         attribute from { text }?,
         <phrase role="highlight">attribute when { pathValue }?</phrase>,
         rich,
         (foreign &amp; inclusion* &amp; (p*, let*, active*))
     }</programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/71">Enhancement for sch:phase - @when</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example xml:id="when-att">
                    <title><literal>from</literal> attribute</title>
                    <para>Given this instance document:</para>
                    <programlisting language="xml"><![CDATA[<foo>
<blort wibble='1'/>
<bar><blort wibble='2'/><blort wibble='3'/></bar>
</foo>]]></programlisting>
                    <para>and this schema:</para>
                    <programlisting language="xml"><![CDATA[<sch:schema schematronEdition='2025'>
  <sch:phase id='foo' ]]><phrase role="highlight">when='/foo'</phrase><![CDATA[>
    ]]><phrase role="highlight"><![CDATA[<sch:active pattern='wibble-1'/>]]></phrase><![CDATA[
  </sch:phase>
  <sch:phase id='wibble' when='//@wibble'>
    <sch:active pattern='wibble-2'/>
  </sch:phase>
  <sch:phase id='bar' when='/foo/bar'>
    <sch:active pattern='wibble-3'/>
  </sch:phase>
  <sch:pattern id=']]><phrase role="highlight">wibble-1</phrase><![CDATA['>
    <sch:rule context='//blort[@wibble]'>
      <sch:report test='@wibble'><sch:value-of select='@wibble'/></sch:report>
    </sch:rule>
  </sch:pattern>
  <sch:pattern id='wibble-2'>
    <sch:rule context='//blort[@wibble]'>
      <sch:report test='@wibble'><sch:value-of select='@wibble/..'/></sch:report>
    </sch:rule>
  </sch:pattern>
  <sch:pattern id='wibble-3'>
    <sch:rule context='//blort[@wibble]'>
      <sch:assert test='normalize-space(@wibble)'>value must not be empty</sch:assert>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>
                    <para>all instances of the <tag class="attribute">when</tag> attribute match when evaluated against the document instance, but only the <emphasis>first</emphasis> matching phase in document order (<literal>wibble-1</literal>) is selected:</para>
                    <programlisting language="xml"><![CDATA[<svrl:schematron-output xmlns:svrl="http://purl.oclc.org/dsdl/svrl" ]]><phrase role="highlight">phase="foo"</phrase><![CDATA[>
  ]]><phrase role="highlight"><![CDATA[<svrl:active-pattern id="wibble-1"/>]]></phrase><![CDATA[
  <svrl:fired-rule context="//blort[@wibble]"/>
  <successful-report xmlns="http://purl.oclc.org/dsdl/svrl" location="/Q{}foo[1]/Q{}blort[1]" test="@wibble">
    <svrl:text>1</svrl:text>
  </successful-report>
  <successful-report xmlns="http://purl.oclc.org/dsdl/svrl" location="/Q{}foo[1]/Q{}bar[1]/Q{}blort[1]" test="@wibble">
    <svrl:text>2</svrl:text>
  </successful-report>
  <successful-report xmlns="http://purl.oclc.org/dsdl/svrl" location="/Q{}foo[1]/Q{}bar[1]/Q{}blort[2]" test="@wibble">
    <svrl:text>3</svrl:text>
  </successful-report>
</svrl:schematron-output>]]></programlisting>
                    <note><para>This result is obtained only if the implementation is invoked using <literal>#ANY</literal> to specify that the phase should be dynamically selected by evaluating <tag class="attribute">when</tag> attributes.</para>
                    <para>If no phase is selected with this schema, the behaviour matches that of specifying <literal>#ALL</literal> instead: <emphasis>all</emphasis> patterns become active and <emphasis>all</emphasis> are therefore evaluated.</para></note>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>The introduction of this attribute entails the new string <literal>#ANY</literal> to specify that <tag class="attribute">when</tag> should be used to determine the active phase.</para>
                <para>Like <literal>#ALL</literal> and <literal>#DEFAULT</literal>, <literal>#ANY</literal> is not to be used as a phase name in a schema, but instead to invoke or configure validation, for example when passed as a parameter to an implementation at the command line.</para>
            </section>
        </chapter>
    </part>
    <part>
        <title>New elements</title>
        <chapter>
            <title><tag class="element">group</tag></title>
            <para>This element has the same content model as element <tag class="element">pattern</tag>. Patterns and groups may be combined in a schema.</para>
            <blockquote role="iso" xml:id="group-elem">
                <title>Clause 5.4.5 (<literal>group</literal> element)</title>
                <para>The <literal>group</literal> element has the same structure and semantics as element <literal>pattern</literal> [...], except that the if-then-else behaviour of evaluating rules within a pattern shall not apply (see <link linkend="order-side-effects">6.6</link>).</para>
            </blockquote>
            <blockquote role="iso" xml:id="order-side-effects">
                <title>Clause 6.6 Order and side-effects</title>
                <para>A <literal>rule</literal> element acts as an if-then-else statement within each pattern. In the context of a <literal>group</literal> element (<link linkend="group-elem">5.4.5</link>), this behaviour shall not apply and a match shall be attempted instead against all the rule contexts it contains.</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting>element schema {
        attribute id { xsd:ID }?,
        rich,
        attribute schemaVersion { non-empty-string }?,
        attribute schematronEdition { non-empty-string }?,
        attribute defaultPhase { xsd:IDREF }?,
        attribute queryBinding { non-empty-string }?,
        (foreign
         &amp; (inclusion | extends)*
         &amp; (title?, ns*, p*, param*, let*, phase*, abstract-rules*, (<phrase role="highlight">rule-set</phrase>|pattern)+, p*, diagnostics?, properties?))
    }</programlisting>
                <programlisting>element library {
        attribute id { xsd:ID }?,
        rich,
        (foreign
         &amp; (inclusion | extends)*
         &amp; (title?, p*, param*, let*, abstract-rules*, (<phrase role="highlight">rule-set</phrase>|pattern)*, p*, diagnostics?, properties?))
    }</programlisting>
                <programlisting>rule-set = 
    element <phrase role="highlight">group</phrase> {
        rule-set-or-pattern    
    }</programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/25">Option to turn off if-then-else behaviour within patterns</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example xml:id="group-elem-example">
                    <title><literal>group</literal> element</title>
                    <para>Given this instance document:</para>
                    <programlisting language="xml"><![CDATA[<foo/>]]></programlisting>
                    <para>and this schema:</para>
                    <programlisting language="xml"><![CDATA[<sch:schema schematronEdition='2025'>
  ]]><phrase role="highlight">&lt;sch:group></phrase><![CDATA[
    <sch:rule context='*'>
      <sch:assert test='name() eq "bar"'>root element is <sch:name/></sch:assert>
    </sch:rule>
    <sch:rule context='foo'>
      <sch:report test='.'>should reach here</sch:report>
    </sch:rule>
  ]]><phrase role="highlight">&lt;/sch:group></phrase><![CDATA[
</sch:schema>]]></programlisting>
                    <para><emphasis>both</emphasis> rules will fire and their assertions will be evaluated, because within the context of a <tag class="element">group</tag>, all rules are evaluated. Contrast this with <tag class="element">pattern</tag>: in this instance, only the <emphasis>first</emphasis> rule would fire (if a child of <tag class="element">pattern</tag>), because the context has already been matched when the second rule's context is evaluated.</para>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>This element gives the option to have <emphasis>all</emphasis> rules evaluated regardless, addressing one of the commonest issues faced by schema authors.</para>
            </section>
        </chapter>
        <chapter>
            <title><tag class="element">library</tag></title>
            <itemizedlist>
                <title>Element context(s)</title>
                <listitem>
                    <para><tag class="element">library</tag> is a root element</para>
                </listitem>
            </itemizedlist>
            <blockquote role="iso" xml:id="library-elem">
                <title>Clause 5.4.8 (<literal>library</literal> element)</title>
                <para>The library element is an allowed root element containing external declarations, including abstract rules [...] and patterns [...].The contents of this element can be included in a schema by using <tag class="element">extends</tag>.</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting>element <phrase role="highlight">library</phrase> {
        attribute id { xsd:ID }?,
        rich,
        (foreign
         &amp; (inclusion | extends)*
         &amp; (title?, p*, param*, let*, abstract-rules*, (rule-set|pattern)*, p*, diagnostics?, properties?))
    }</programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/39">A library system for abstract patterns and abstract rule-sets</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example xml:id="library-elem-example">
                    <title><literal>library</literal> element</title>
                    <para>Given this schema:</para>
                    <programlisting language="xml"><![CDATA[<sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron" queryBinding="xquery" schematronEdition='2025'>
  <sch:extends href=']]><phrase role='highlight'>library.sch</phrase><![CDATA['/>
  <sch:pattern>
    <sch:rule context="/">
      <sch:assert test="true()">Always true</sch:assert>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>
                    <para>and the library imported via <tag class="element">extends</tag> from <literal>library.sch</literal> (see highlight above):</para>
                    <programlisting language="xml"><![CDATA[<library xmlns="http://purl.oclc.org/dsdl/schematron">
    <pattern id='blort'>
        <rule context="blort">
            <assert test="@wibble">Element <name/> must have attribute 'wibble'</assert>
        </rule>
    </pattern>    
    <pattern id='wibble'>
        <rule context="wibble">
            <assert test=". = $some-global">Element <name/> must have value '<value-of select="$some-global"/>'</assert>
        </rule>
    </pattern>    
</library>]]></programlisting>
                    <para>the contents of the library will be included in place of the <tag class="element">extends</tag> element, to produce the resulting schema:</para>
                    <programlisting language="xml"><![CDATA[<sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron" queryBinding="xquery" schematronEdition='2025'>
  ]]><phrase role="highlight"><![CDATA[<pattern xmlns="http://purl.oclc.org/dsdl/schematron" id="blort">
        <rule context="blort">
            <assert test="@wibble">Element <name/> must have attribute 'wibble'</assert>
        </rule>
    </pattern>
  <pattern xmlns="http://purl.oclc.org/dsdl/schematron" id="wibble">
        <rule context="wibble">
            <assert test=". = $some-global">Element <name/> must have value '<value-of select="$some-global"/>'</assert>
        </rule>
    </pattern>]]></phrase><![CDATA[
  <sch:pattern>
    <sch:rule context="/">
      <sch:assert test="true()">Always true</sch:assert>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>This element is a convenience for building modular schemas, featuring a pared-down version of element <tag class="element">schema</tag>'s content model.</para>
            </section>
        </chapter>
        <chapter>
            <title><tag class="element">rules</tag></title>
            <itemizedlist>
                <title>Element context(s)</title>
                <listitem>
                    <para><tag class="element">library</tag></para>
                </listitem>
                <listitem>
                    <para><tag class="element">schema</tag></para>
                </listitem>
            </itemizedlist>
            <blockquote role="iso" xml:id="rules-elem">
                <title>Clause 5.4.16 (<literal>rules</literal> element)</title>
                <para>The rules element is a container for abstract rules, allowing their use across patterns. This element may be used as a top-level element in a schema and can also be used in a library.</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting>element schema {
        attribute id { xsd:ID }?,
        rich,
        attribute schemaVersion { non-empty-string }?,
        attribute schematronEdition { non-empty-string }?,
        attribute defaultPhase { xsd:IDREF }?,
        attribute queryBinding { non-empty-string }?,
        (foreign
         &amp; (inclusion | extends)*
         &amp; (title?, ns*, p*, param*, let*, phase*, <phrase role="highlight">abstract-rules</phrase>*, (rule-set|pattern)+, p*, diagnostics?, properties?))
    }</programlisting>
                <programlisting>element library {
        attribute id { xsd:ID }?,
        rich,
        (foreign
         &amp; (inclusion | extends)*
         &amp; (title?, p*, param*, let*, <phrase role="highlight">abstract-rules</phrase>*, (rule-set|pattern)*, p*, diagnostics?, properties?))
    }</programlisting>
                <programlisting>abstract-rules =
    element <phrase role="highlight">rules</phrase> {
        attribute id { xsd:ID }?,
        rich,
        title?,
        p*,
        abstract-rule+
    }</programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/3">A container element for abstract Schematron rules</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example xml:id="rules-elem-example">
                    <title><literal>rules</literal> element</title>
                    <para>Given this schema:</para>
                    <programlisting language="xml"><![CDATA[<sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron" schematronEdition='2025'>
  ]]><phrase role="highlight"><![CDATA[<sch:rules>
    <sch:rule abstract="true" id="abstract-rule">
      <sch:report test="self::element"/>
    </sch:rule>
    <sch:rule abstract="true" id="abstract-rule-2">
      <sch:report test="name()"/>
    </sch:rule>
  </sch:rules>]]></phrase><![CDATA[
  <sch:pattern>
    <sch:rule context="element">
      <sch:extends rule="abstract-rule"/>
    </sch:rule>
    <sch:rule context="*">
      <sch:extends rule="abstract-rule-2"/>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>
                    <para>the two abstract <tag class="element">rule</tag> elements contained in <tag class="element">rules</tag> will be instantiated as usual, resulting in this expanded schema:</para>
                    <programlisting language="xml"><![CDATA[<sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron" schematronEdition='2025'>
  <sch:pattern>
    ]]><phrase role='highlight'><![CDATA[<sch:rule context="element">
      <sch:report test="self::element"/>
    </sch:rule>
    <sch:rule context="*">
      <sch:report test="name()"/>
    </sch:rule>]]></phrase><![CDATA[
  </sch:pattern>
</sch:schema>]]></programlisting>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>The behaviour of abstract rules and how they are processed remains unchanged here. What is new is the container for abstract rules, which would previously have to have been stored separately and instantiated using <tag>extends/@href</tag>.</para>
                <para>More background on this can be found in <link xlink:href="https://dmaus.name/blog/2021.02/">this blog post</link> by David Maus.</para>
            </section>
        </chapter>
    </part>
    <part>
        <title>New functionality</title>
        <chapter xml:id="dynamic-atts">
            <title>Dynamic evaluation of attributes <tag class="attribute">flag</tag>, <tag class="attribute">role</tag> and <tag class="attribute">severity</tag></title>
            <blockquote role='iso'>
                <title>Clauses 5.5.6 (<literal>role</literal> attribute), 5.5.14 (<literal>role</literal> attribute), 5.5.16 (<literal>severity</literal> attribute)</title>
                <para>If the value of a [<literal>flag</literal>, <literal>role</literal>, <literal>severity</literal>] attribute given in a schema is a variable reference, its value shall be dynamically evaluated. This mechanism is provided to enable the [...] value to vary, for example according to the selected phase and its in-scope variables.</para>
            </blockquote>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/64">Ability for role value to be dynamic or different per phase</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example>
                    <title>Dynamic evaluation of attributes</title>
                    <para>The following schema</para>
                    <programlisting language="xml"><![CDATA[<sch:schema defaultPhase='phase' schematronEdition='2025'>
  <sch:ns prefix='a' uri='b'/>
  <sch:let name='c' value='d'/>
  <sch:phase id='phase'>
    ]]><phrase role="highlight"><![CDATA[<sch:let name='flag' value='"foo"'/>
    <sch:let name='role' value='"bar"'/>
    <sch:let name='severity' value='"blort"'/>]]></phrase><![CDATA[
    <sch:active pattern='foo'/>
  </sch:phase>
  <sch:pattern id='foo'>
    <sch:rule context='*'>
      <sch:assert test='false()' ]]><phrase role='highlight'>flag='$flag' role='$role' severity='$severity'</phrase><![CDATA[></sch:assert>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>
                    <para>would result in SVRL containing this <tag class="element">failed-assert</tag>:</para>
                    <programlisting language="xml"><![CDATA[<svrl:failed-assert test='false()' ]]><phrase role='highlight'>flag='foo' role='bar' severity='blort'</phrase><![CDATA[/>]]></programlisting>
                </example>
            </section>
        </chapter>
        <chapter xml:id="uri-lang-fixup">
            <title>Base URI and language fixup</title>
            <blockquote role='iso'>
                <title>Clauses 6.7 (Localization and language fixup)</title>
                <para>An implementation shall perform language fixup according to the method defined in section 4.5.6 of XInclude 1.0 when incorporating external definitions (via elements <literal>include</literal> and <literal>extends</literal>) and instantiating abstract patterns, abstract rules, diagnostics, and properties.</para>
            </blockquote>
            <blockquote role='iso'>
                <title>Clauses 6.8 (Base URI fixup)</title>
                <para>An implementation shall perform base URI fixup according to the method defined in section 4.5.5 of XInclude 1.0 when incorporating external definitions (via elements <literal>include</literal> and <literal>extends</literal>).</para>
            </blockquote>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/2">Base URI fixup</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <para>Note this relates to the resolution of URIs during the inclusion of external declarations.</para>
            </section>
        </chapter>
        <chapter xml:id="schema-param">
            <title>Schema-level parameters (top-level <tag class="element">param</tag> elements)</title>
            <blockquote role='iso'>
                <title>Clauses 5.4.11 (<literal>param</literal> element)</title>
                <para>The  <literal>param</literal>  element specifies a name-value pair providing parameters for an abstract pattern or a schema. [...] The  <literal>value</literal>  attribute is a fragment of a query. The <literal>value</literal> attribute is required for parameters specified for schemas. The value of a parameter for a schema may be overridden at user option. This mechanism is implementation-defined.</para>
                <para>Parameter names shall be distinct within the scope of a pattern or schema.</para>
            </blockquote>
            <section>
                <title>Declaration</title>
                <programlisting>element schema {
        attribute id { xsd:ID }?,
        rich,
        attribute schemaVersion { non-empty-string }?,
        attribute schematronEdition { non-empty-string }?,
        attribute defaultPhase { xsd:IDREF }?,
        attribute queryBinding { non-empty-string }?,
        (foreign
         &amp; (inclusion | extends)*
         &amp; (title?, ns*, p*, <phrase role="highlight">param*</phrase>, let*, phase*, abstract-rules*, (rule-set|pattern)+, p*, diagnostics?, properties?))
    }</programlisting>
            </section>
            <section>
                <title>Related GitHub issue(s)</title>
                <para><link xlink:href="https://github.com/Schematron/schematron-enhancement-proposals/issues/34">Pass parameters to the validating stylesheet at validation runtime</link></para>
            </section>
            <section>
                <title>Sample usage</title>
                <example>
                    <title>Schema-level parameters</title>
                    <para>Validating a document against this schema:</para>
                    <programlisting language="xml"><![CDATA[<sch:schema schematronEdition='2025'>]]>
  <phrase role='highlight'><![CDATA[<sch:param name='myParam' value='"bar"'/>]]></phrase><![CDATA[
  <sch:pattern id='foo'>
    <sch:rule context='*'>
      <sch:assert test='false()'><sch:value-of select=']]><phrase role="highlight">$myParam</phrase><![CDATA['/></sch:assert>
    </sch:rule>
  </sch:pattern>
</sch:schema>]]></programlisting>
                    <para>would result in SVRL containing:</para>
                    <programlisting language="xml"><![CDATA[<svrl:failed-assert test='false()'>]]><phrase role="highlight">bar</phrase><![CDATA[</svrl:failed-assert>]]></programlisting>
                </example>
            </section>
            <section>
                <title>Commentary</title>
                <para>Note the wording "[...] <emphasis>may</emphasis> be overridden at user option", which means overriding a parameter in this way is permitted but is not a feature implementations are obliged to support.</para>
            </section>
        </chapter>
    </part>
</book>